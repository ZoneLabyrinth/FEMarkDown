## First Contentful Paint

#### FP和FCP的不同

用户体验上：

##### FP

当浏览器检测到任何渲染就会触发FP。这些渲染可能是背景颜色的微妙变化和无意义的信息

![img](https://gtmetrix.com/blog/wp-content/uploads/2017/11/first-paint-example.png)

这个时间的问题是首次渲染可以在页面加载相对较早的触发，而这些加载并不一定提供任何内容或者信息给用户。网站组件的加载可以以交错的方式而背景颜色可能更快的渲染，实际的内容、交互则可能花费更多的时间。

在这种情况下，FP计时会产生误导，因为你的网站可能在很久之后才加载出有用或无用的信息。



FCP

当任何`content`被渲染时就会触发FCP ——即一些DOM定义的内容。这些`content`可以是文本，图片或者是`canvas`

![img](https://gtmetrix.com/blog/wp-content/uploads/2017/11/first-contentful-paint-example.png)

这个时间目的是为了更能代表你的用户体验，因为它标记了在页面中加载世纪内容的时间，而不仅仅是任何更改。

由于重点是内容，因此该指标可以让你了解你的用户何时收到有用的信息。



## 关注哪一个

FCP无疑比FP更准确——然而，通常这两个时间最终都是一样的。

在某些情况下，你可能更喜欢使用其中一种或另一种：

- 在更快更轻的网站上，由于浏览器可以快速渲染元素，FP和FCP更可能是一样的。如果他们相同，那么无论是FP还是FCP就足够了。
- 在大且复杂的网站上——由于多元素需要处理，你可能会发现FP和FCP更经常的不同。在这些网站上，使用FCP会是更好的指标。



### 展示地方



















译自：

https://gtmetrix.com/blog/first-contentful-paint-explained/





## First Meaningful  paint

(原文：https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/edit?spm=a2c4e.11153940.blogcont598162.16.f341552224hv3Q#)

首次有效渲染是当屏幕显示出页面主要内容的时间。这将会是我们表示用户预加载体验的主要指标。

不同的页面对主要内容有不同的定义。对于博客文章，主要内容可能是标题+未折叠的文本(文本必须是可见的，而不是等待加载字体)。对于搜索引擎来说，这将会是搜索结果。如果有一个图像对于页面至关重要(例如金融产品页面)，那么FMP需要等到他加载完成。对于仅仅是标题，导航栏，或者如用于加载指示的spinner图标的渲染都不重要。

在这篇文档中，我们建议使用一个基于布局的方法——已经在198个页面中的77%匹配了用户体验的FMP，来近似表示所有FMP

### 方法设计

#### 基本方法：计算布局对象。

随着页面的加载，布局对象将逐步添加到布局树中。

图1显示了当加载谷歌搜索结果页时一些布局对象加入页面时时间。

图2是从测试页面结果加载页面的可视进度

![スクリーンショット 2016-04-04 午後7.20.58.png](http://ww4.sinaimg.cn/large/006tNc79ly1g3h4srarp9j30db09r0t1.jpg)

​															**图1**



![スクリーンショット 2016-04-04 午後6.55.23.png](http://ww1.sinaimg.cn/large/006tNc79ly1g3h4sozhglj30jm06i0uu.jpg)

​															**图2**

FCP(1.577s)仅仅是页面头部渲染，并且直到1.76s时顶部广告被特别渲染后，60个布局对象才开始被添加，在哪个时间点，所有的布局对象总共有103个；大约1.86s，搜索结果完成，并且261个对象被加入布局树中。在接下来的绘制中(1.907s)是FMP。之后，剩余的搜索结果和页脚被布局到可视区域下。页面在2.425s完成可视化。



正如你可以从这个例子中看出，许多布局对象和页面加载的"完整性"紧密关联。

















## 优化

#### 优化 FP/FCP

- 在 `<head>` 移除影响 FP/FCP 的 css 和 js 代码
- 将影响首屏渲染的关键 css 代码最小集合直接 inline 写在 `<head>` 中
- 对 react 这种客户端渲染框架，做 ssr
- 本地缓存

#### 优化 FMP/TTI

- 首先需要确定页面中的最关键元素，例如专题中的视频组件，然后需要保证关键组件相关的代码最先加载并且使得关键组件在第一时间被渲染且可交互
- 图片懒加载，组件懒加载
- 其他一些对渲染关键组件无用的代码可以延缓加载
- 减少 html dom 个数和层数
- 尽量缩减 FMP 和 TTI 的时间间隔，最好让用户知道当前页面并未完全可交互。如果用户想要交互但是页面没有响应，那么用户会感到不爽

#### 防止 long tasks

- 将代码分割，并对给不同代码分配不同的加载优先级。不仅能加快页面交互时间，而且可以减少 long tasks
- 对于执行时间特别长的代码，可以尝试让他们[分为几个异步执行的代码块](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)

```
if ('requestIdleCallback' in window) {
  // Use requestIdleCallback to schedule work.
} else {
  // Do what you’d do today.
}
```

- 测试第三方的 js 库，保证不影响执行时间

