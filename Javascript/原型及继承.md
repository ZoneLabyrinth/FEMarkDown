## 创建对象

1. ##### 工厂模式（没解决识别对象类型）

2. ##### 构造函数 （通过`new`操作符）

   相对工厂模式优点：可以将它的实例标识为一种特定的类型（解决识别问题）

   缺点：每个方法都要在每个实例上重新创建一遍（会导致不同作用域链和标识符解析。即不同实例上的同名函数是不相等的。出现的情况：`person1.sayname === person2.sayname //false` （可以通过转移函数到外部））

3. ##### **原型模式**（`prototype`）

   每个函数都有一个`prototype`属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

   - 理解原型对象

     只要创建了新函数，就会根据一组特定规则为该函数创建一个`prototype`属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个`construtor`属性，这是指向原构造函数的指针。

   - `__proto__`

     隐式原型，存在于实例与构造函数的**原型对象**之间，而不是存在与实例和构造函数之间

   - `in`和 `hasOwnProperty`

     `in`：只要通过对象能访问到的就返回`true`

     `hasOwnProperty`：只有在实例上的属性返回`true`

   - 对象字面量创建原型

   ```js
   function Person(){};
   Person.prototype = {
       //手动重置 constructor 
       //否则导致 person1.constructor == Person //false 无法找回 constructor,
       constructor: Person,  //此种重设会导致此属性变为可枚举
       name: 'obj',
       age:'18'
   }
   
   var person1 = new Person();
   ```

   此形式重写了`prototype`对象，则`constructor`指向 `Object`，不再为`Person`。虽然`instanceof`仍返回`true`，但无法通过`constructor`找回对象类型。 即`person1.constructor == Person //false`

   - 动态性

     重写原型会切换与原有原型的联系，引用的仍是原来的原型

     缺点：

     所有实例共享原型属性，对于引用类型，一个改变会引起所有改变。

4. #### 组合构造和原型模式

   ```js
   function Person(name,age){
       this.name = name;
       this.age = age;
       //构造函数不影响
       this.friends = ['a','b']
       
   };
   Person.prototype = {
       constructor: Person,  //此种重设会导致此属性变为可枚举
       sayName: function{ console.log(this.name)}
   }
   
   var person1 = new Person('aaa',18);
   var person2 = new Person('path',20);
   person1.friends.push('c');
   console.log(person1.friends) // a,b,c
   console.log(person2.friends) // a,b
   console.log(person1.sayname === person2.sayname //true, 原型模式中共享
   ```

5. #### 动态原型（构造函数中初始化原型）

6. #### 寄生构造（创建一个函数，封装对象然后return）

   可以用来做特殊类型，添加方法。（返回的对象与构造函数或者原型属性之间没有关系。所以`instanceof`无效。 

   

7. #### 稳妥构造函数（不使用`this`和 `new`，安全）

   没有公共属性

   ```js
   function Person(name,age,job){
       //创建要返回的对象
       var o = new Object()
       //可以在此定义私有变量和函数
       
       //添加方法
       o.sayname = function(){
           console.log(name)
       } 
       //返回对象
       return o
   }
   ```

   除了调用`sayname()`方法发外，没有其他办法访问其数据成员。即使有其他带啊吗会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数的原始数据。



## 继承

#### 原型链继承（利用原型让一个引用类型继承另一个引用类型的属性和方法。）

**原型链**： 让一个原型对象等于另一个类型的实例，层层叠加，形成链式结构

注：添加新方法必须在替换原型之后，即重写。

​		子类继承后不能用**字面量形式**添加新方法，否则会导致继承无效。（切断联系）

缺点： 1. **引用类型**的原型属性会被所有实例共享（相互影响）

			2. 创建子类型实例时，不饿能向超类型的构造函数中传递参数。（无法在不影响其他所有对象实例的情况下）			

#### 结构构造函数继承（apply/call）

```js
function Super(name){
	this.name = name
}

function Sub(){
    //继承，传参
    Super.call(this,'sub')
    
    //实例属性
    this.age = 18
}
var instance = new Sub()
```

优点：向父类传参

缺点：无法函数复用

#### 组合继承

使用**原型链**实现对**原型属性和方法**的继承，通过**借用构造函数**来实现**对实例属性**的继承

```js
function Super(name){
	this.name = name
    this.friends = ['a','b']
}

Super.prototype.sayName = function(){
    console.log(this.name)
}

function Sub(name){
    //继承属性
    //第二次调用
    Super.call(this,name)
    
    //实例属性
    this.age = 18
}
//继承方法 ，第一次调用
Sub.prototype = New Super()
//指回Sub
Sub.prototype.constructor = Sub;
//添加方法
Sub.prototype.sayAge = function(){
    console.log(this.age)
}


var instance1 = new Sub('sub1')
instance1.friends.push('c')

var instance2 = new Sub('sub2')
console.log(instance1) //a,b,c
console.log(instance2) //a,b

```

缺点：调用两次超类构造函数（寄生组合式）

#### 原型式继承(Object.create())

```js
function Objcet(o){
    function F(){}
    F.prototype = o
    return new F()
}
```

只想让一个对象与另一个保持类似时使用，但引用类型会共享相应的值。

#### 寄生式继承

创建一个仅用于封装继承过程的函数，该函数一某种方式来增强对象，最后返回对象。

```js
function createAnother(original){
    //通过调用函数创建一个新对象,任何能够返回新对象的函数都可以视为object()
    var clone = object(original) 
    clone.say = function(){   //以某种方式增强对象
        console.log('hi')  
    }
    return clone  //返回对象
}
```

在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。

#### 寄生组合式继承

通过借用构造函数继承属性，通过原型链的混成形式来继承方法

基本思路：不必为了制定子类型的原型而调用超类的构造函数，我们所需的无非就是超类的副本。

本质上，就是使用**寄生式继承来继承超类的原型**，然后再将结果指定给子类的原型。

```js
function inheritPrototype(sub,super){
	var proto = Object(super.prototype) //创建对象
	proto.constuctor = sub //增强对象
	sub.prototype = proto //指定对象
}


//使用
function Super(name){
	this.name = name
    this.friends = ['a','b']
}

Super.prototype.sayName = function(){
    console.log(this.name)
}

function Sub(name){
    //继承属性，只调用一次
    Super.call(this,name)
    
    //实例属性
    this.age = 18
}
//继承方法
inheritPrototype(Sub,Super)

Sub.prototype.sayAge = function(){
    console.log(this.age)
}


var instance1 = new Sub('sub1')
instance1.friends.push('c')

var instance2 = new Sub('sub2')
console.log(instance1) //a,b,c
console.log(instance2) //a,b
```





