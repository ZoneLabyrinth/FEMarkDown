### CSS:

flex布局

:not()

BFC

创建BFC

浮动，清除

Position 值

sticky粘性定位

使用条件：
 1、父元素不能overflow:hidden或者overflow:auto属性。
 2、必须指定top、bottom、left、right4个值之一，否则只会处于相对定位
 3、父元素的高度不能低于sticky元素的高度
 4、sticky元素仅在其父元素内生效





跨域，同源策略

em,rem





### js

typescript

flatten数组 

```js
const flatten = (arr)=>{
		return arr.reduce((item,next)=>{
      	item.concat(Array.isArray(next)?flatten(item):item)
    })
}
```



### reduce(()=>{}) 

// []

### map(()=>{})

 // [undefined,undefined,undefined]

### Call,apply,bind实现

### Eventloop 

### setTimeout 第三个参数

定时器启动时候，第三个以后的参数是作为第一个`func()`的参数传进去。

### 

### async defer

先来试个一句话解释仨，当浏览器碰到 `script` 脚本的时候：

1. <script src="script.js"></script>
没有 `defer` 或 `async`，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 `script` 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
  
2. <script async src="script.js"></script>
有 `async`，加载和渲染后续文档元素的过程将和 `script.js` 的加载与执行并行进行（异步）。
  
3. <script defer src="myscript.js"></script>
有 `defer`，加载后续文档元素的过程将和 `script.js` 的加载并行进行（异步），但是 `script.js` 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。理论上会按照加载顺序来执行，但实际上不一定
  


### 事件代理委托(jquery实现、优缺点)

**事件委托原理：**事件冒泡机制；

**优点：**

1、可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错；

2、可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为适合；

**缺点：**

事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件；

原型链

深拷贝浅拷贝

数组交并集

...扩展运算符 浅拷贝，修改时是深拷贝

symbol





### react

生命周期（废弃及新生成）

性能优化

context

immutable



hooks实现类组件生命周期

diff算法

redux工作流程，原理 http://zhuanlan.zhihucom/p/25585910?refer=purerender

immutable

事件处理和原生JS

redux更新时，ui组件是否更新



作者：寸志
链接：https://www.zhihu.com/question/56820346/answer/150724784
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## require/exports 和 import/export 本质上的差别

形式上看起来五花八门，但本质上：

1. CommonJS 还是 ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象；
2. default 是 ES6 Module 所独有的关键字，export default fs 输出默认的接口对象，import fs from 'fs' 可直接导入这个对象；
3. ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。

1、2 相对比较好理解，3 需要看个例子：

```js
// counter.js
exports.count = 0
setTimeout(function () {
  console.log('increase count to', ++exports.count, 'in counter.js after 500ms')
}, 500)

// commonjs.js
const {count} = require('./counter')
setTimeout(function () {
  console.log('read count after 1000ms in commonjs is', count)
}, 1000)

//es6.js 
import {count} from './counter'
setTimeout(function () {
  console.log('read count after 1000ms in es6 is', count)
}, 1000)
```

分别运行 commonjs.js 和 es6.js：

```bash
➜  test node commonjs.js
increase count to 1 in counter.js after 500ms
read count after 1000ms in commonjs is 0
➜  test babel-node es6.js
increase count to 1 in counter.js after 500ms
read count after 1000ms in es6 is 1
```



### vue

data返回函数

V-if和v-show







### webpack

配置

多线程原理



