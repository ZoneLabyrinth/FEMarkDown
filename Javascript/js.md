### Q:class 和 function 的区别

class 也是一个语法糖，本质还是基于原型链，class 语义化和编码上更加符合面向对象的思维。

对于 `function` 可以用 `call apply bind` 的方式来改变他的执行上下文，但是 `class` 却不可以，class 虽然本质上也是一个函数，但在转成 es5 （babel）做了一层代理，来禁止了这种行为。

- class 中定义的方法不可用 `Object.keys()` 遍历
- class 不可以定义私有的属性和方法， function 可以，只要不挂载在 this 作用域下就行
- class 只能通过类名调用
- class 的静态方法，this 指向类而非实例

### 四舍五入：

toFixed：五舍六入

Math.round:整数四舍五入



### Q:垃圾回收机制

为什么需要垃圾回收：因为对象需要占用内存，而内存资源是有限的。

js 会周期性的对不在使用的对象销毁，释放内存，关键点就在于怎么识别哪些对象是垃圾。

垃圾对象：对象没有被引用，或者几个对象形成循环引用，但是根访问不到他们，这些都是可回收的垃圾。

垃圾回收的两种机制：标记清除和引用计数

#### 标记清除法

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

比如说函数中声明了一个变量，就做一个标记，当函数执行完成，退出执行栈，这个变量的标记就变成已使用完。

目前主流浏览器采用的是这个策略

#### 引用计数

跟踪每个值被引用的次数，声明一个变量后，这个变量每被其他变量引用一次，就加 1 ，如果变量引用释放了，就减 1，当引用次数为 0 的时候，对象就被清理。但这个有个循环引用的弊端，所以应用的比较少。

#### 垃圾收集的性能优化

1. 分代回收，对象分成两组，新生带、老生带，
2. 增量回收
3. 空闲时间回收

#### 编码可以做的优化

1. 避免重复创建对象。
2. 在适当的时候解除引用，是为页面获的更好性能的一个重要方式。
3. 全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

 :观察者模式  发布-订阅模式 的区别

两者都是订阅-通知的模式，区别在于：

观察者模式：观察者和订阅者是互相知道彼此的，是一个紧耦合的设计

发布-订阅：观察者和订阅者是不知道彼此的，因为他们中间是通过一个订阅中心来交互的，订阅中心存储了多个订阅者，当有新的发布的时候，就会告知订阅者

设计模式的名词实在有点多且绕，我画个简单的图：



![dingyue](https://user-gold-cdn.xitu.io/2020/2/23/170714948516ec93?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### Q:WebSocket

这个就问到了一次，所以简单进行了了解。

简单来说，WebSocket 是应用层协议，基于 tcp，与HTTP协议一样位于应用层，都是TCP/IP协议的子集。



![socket-tcp](https://user-gold-cdn.xitu.io/2020/2/23/170714914277ef0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



HTTP 协议是单向通信协议，只有客户端发起HTTP请求，服务端才会返回数据。而 WebSocket 协议是双向通信协议，在建立连接之后，客户端和服务器都可以主动向对方发送或接受数据。



![socket-http](https://user-gold-cdn.xitu.io/2020/2/23/1707148e460db8dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

useEffect uselayoutEffect



主要就是effect和layoutEffect队列的执行阶段，layout会在组件树构建完毕或者刷新完毕后同步立刻执行。effect会等其他js代码执行完毕后执行（或者遇到下一次刷新任务前）





