

## HTTP

### HTTP 1.1

1. put,delete等方法，
2. 增加了缓存机制
3. 明确了连接管理，允许持久连接
4. 允许响应数据分块，利于传输文件
5. 强制要求Host头，让互联网主机托管成为可能



HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

- **二进制协议，不再是纯文本；**
- **可发起多个请求，废弃了 1.1 里的管道**；
- **使用专用算法压缩头部，减少数据传输量；**
- **允许服务器主动向客户端推送数据；**
- **增强了安全性，“事实上”要求加密通信。**

虽然 HTTP/2 到今天已经四岁，也衍生出了 gRPC 等新协议，但由于 HTTP/1.1 实在是太过经典和强势，目前它的普及率还比较低，大多数网站使用的仍然还是 20 年前的 HTTP/1.1。





























## HTTPS

HTTPS是在HTTP建立SSL加密层，实现对数据的传输加密，是HTTP的安全版。

主要作用：

1. 对数据加密，并建立一个信息安全通道，来保证传输过程中的数据安全；
2. 对网站服务器进行真实身份认证



### 为什么需要HTTPS

##### HTTP存在的问题：

- 通信使用明文(不加密)，内容可能被窃听
- 无法证明报文的完整性，所以可能遭篡改
- 不验证通信放的身份，因此可能遭遇伪装



##### HTTPS优势：

- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密秘钥；
- 数据完整性：内容传输经过完整性校验
- 身份认证：第三方无法伪造服务端(客户端)身份

##### 加密方式：

- 对称加密：所有报文用密钥加密，同时把密钥发送至服务端解密。速度块
- 非对称加密：服务端存储私钥，客户端用公钥加密后发送密文，不再发送公钥。解密效率低
- SSL：通过非对称加密协商出对称加密的密钥。先通过非对称 加密 对称的密钥，发送至服务端解密，之后都使用对称加密。



## Cookie

首次访问 服务器创建身份标识  **key-value**，放进Set-Cookie字段，发送至浏览器。当不够时，可能在响应头添加多个`Set-Cookie`，存储多个`key-value`。但浏览器发送时不需要多个Cookie字段，只要在一行用“;”隔开

`Cookie`由浏览器负责存储，而不是操作系统。所以是“浏览器绑定的”，只在本浏览器生效

- ### **属性**

  - **有效期**：**Expires**（过期时间，用绝对时间点 new Date()），可以理解为 **Deadline**；**Max-Age**，用的相对时间，单位是秒，浏览器用收到的报文的时间点再加上 Max-Age,就可以得到失效的绝对时间；

    **Expires**和 **Max-Age**可以同时出现，失效时间也可以不同，但浏览器会优先采用 **Max-Age**计算失效期

  - **作用域：** **Domain**和 **Path**制定了Cookie所属的域名和路径。浏览器发送Cookie前会从URI中提取出`host`和`path`部分，对比Cookie的属性。如果不满足条件，久不会在请求头里发送Cookie。

  - **安全性：** **HttpOnly**只能通过浏览器HTTP协议传输，禁止其他方式访问（防止XSS）；**SameSite** 可以防范“跨站请求伪造（XSRF）”，设置成“`SameSite=Strict`”可以严格限定Cookie不能随挑战链接跨站发送，而"`SameSite=Lax`"则略宽松，允许`GET/HEAD`等安全方法，但禁止`POST`跨站发送； **Secure** 则只允许HTTPS协议加密传输

- ### 应用

  - **身份识别**
  - **广告跟踪** （第三方Cookie）

## 缓存

“**Cache-Control**”：资源有效期，值为“**max-age=60**”，缓存60秒后过期。此 **max-age**为服务器创建响应报文的时间，而不是客户端收到报文后的时间，即包含传输过程中耗时

**max-age**值：

- no-store: **不允许缓存**，用于某些变化非常频繁的数据，例如秒杀页面；
- no-cache：**可以缓存**，但在使用前必须去服务器验证是否过期，是否有最新的版本
- must-revalidate: 如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证

**条件请求：**

​	条件请求一共5个头字段，最常用的是'**if-Modified-since**'和 **if-Node-Match**，需要第一次相应的报文预先提供 **Last-modified**和 **ETag**，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。

如果资源没有变，服务器就返回 **304 Not Modified**，表示缓存依然有效，浏览器就可以更新有效期。

**Last-modified**就是上次修改时间，**ETag**，（Entity Tag），是 **资源的唯一标识符**，用来解决修改时间无法区分文件的问题，如一个文件在一秒内修改了两次，所以无法区分。有强弱之分



## 缓存代理服务

首先，我们要区分客户端上的缓存和代理上的缓村。

**private** 表示缓存只能在客户端保存，是用户“私有的”，不能放在代理上与别人共享（如用户ID）。而 **public**的意思就是缓存完全开放，谁都可以存，谁都可以用。

缓存失效的重新验证也要区分开（即使用条件请求“Last-modified"和”ETag“）

​	**must-revalidate**是只要国企就必须回源服务器验证，而心的 **proxy-revalidate**只要求代理缓存国企后必须验证。客户端不必回源，只需验证到代理

**s-maxage**：缓存的生存时间，只限定在代理上能够存多久，而客户端仍然使用"max-age"

**no-transform**： 禁止代理处理数据。代理有时候对缓存下的数据做一些优化，如图片生成png，webp等多种格式，方便今后的请求处理



![img](https://static001.geekbang.org/resource/image/09/35/09266657fa61d0d1a720ae3360fe9535.png)



源服务器在设置完 **Cache-Control**后必须要为报文加上 **Last-modified**或 **ETag**字段，否则，客户端和代理后面就无法使用条件请求来验证缓存是否游戏，也就不会有304缓存重定向

![img](https://static001.geekbang.org/resource/image/47/92/47c1a69c800439e478c7a4ed40b8b992.png)





